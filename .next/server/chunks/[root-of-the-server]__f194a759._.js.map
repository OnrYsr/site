{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///Users/home/Desktop/site/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import NextAuth, { AuthOptions } from 'next-auth';\nimport CredentialsProvider from 'next-auth/providers/credentials';\nimport { PrismaClient } from '@prisma/client';\nimport bcrypt from 'bcryptjs';\nimport { \n  checkIPRateLimit, \n  checkEmailRateLimit, \n  resetRateLimits, \n  getClientIP \n} from '@/lib/redis';\n\nconst prisma = new PrismaClient();\n\nexport const authOptions: AuthOptions = {\n  providers: [\n    CredentialsProvider({\n      name: 'Credentials',\n      credentials: {\n        email: { label: 'Email', type: 'email' },\n        password: { label: 'Password', type: 'password' },\n      },\n      async authorize(credentials, req) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        try {\n          // Development: Bypass rate limiting for now\n          // TODO: Re-enable for production\n          /*\n          // Get client IP\n          const clientIP = getClientIP(req as any);\n          \n          // Check IP rate limit\n          const ipLimit = await checkIPRateLimit(clientIP);\n          if (!ipLimit.allowed) {\n            const resetMinutes = Math.ceil((ipLimit.resetTime - Date.now()) / (1000 * 60));\n            throw new Error(`IP_BLOCKED:${resetMinutes}`);\n          }\n\n          // Check email rate limit\n          const emailLimit = await checkEmailRateLimit(credentials.email);\n          if (!emailLimit.allowed) {\n            const resetMinutes = Math.ceil((emailLimit.resetTime - Date.now()) / (1000 * 60));\n            throw new Error(`EMAIL_BLOCKED:${resetMinutes}`);\n          }\n\n          // Add progressive delay\n          const delay = Math.max(ipLimit.delaySeconds, emailLimit.delaySeconds);\n          if (delay > 0) {\n            await new Promise(resolve => setTimeout(resolve, delay * 1000));\n          }\n          */\n\n          // Check user credentials\n          const user = await prisma.user.findUnique({\n            where: { email: credentials.email },\n          });\n\n          if (user) {\n            const passwordMatch = await bcrypt.compare(credentials.password, user.password);\n            \n            if (passwordMatch) {\n              // Development: Bypass rate limit reset\n              // await resetRateLimits(clientIP, credentials.email);\n              \n              return { \n                id: user.id, \n                name: user.name || '', \n                email: user.email,\n                role: user.role \n              };\n            }\n          }\n          \n          // Invalid credentials - rate limits already incremented\n          throw new Error('INVALID_CREDENTIALS');\n          \n        } catch (error) {\n          console.error('Auth error:', error);\n          \n          // Re-throw rate limit errors\n          if (error instanceof Error && error.message.startsWith('IP_BLOCKED:')) {\n            throw error;\n          }\n          if (error instanceof Error && error.message.startsWith('EMAIL_BLOCKED:')) {\n            throw error;\n          }\n          \n          // For other errors, just return null (invalid credentials)\n          return null;\n        }\n      },\n    }),\n  ],\n  session: { strategy: 'jwt' },\n  pages: {\n    signIn: '/auth/login',\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.role = (user as any).role;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (token && session.user) {\n        session.user.id = token.sub!;\n        session.user.role = token.role as string;\n      }\n      return session;\n    },\n    async redirect({ url, baseUrl }) {\n      // If URL is provided and starts with baseUrl, use it\n      if (url.startsWith(baseUrl)) {\n        return url;\n      }\n      \n      // Otherwise redirect to home page\n      return baseUrl + '/';\n    },\n  },\n  debug: process.env.NODE_ENV === 'development',\n};\n\nconst handler = NextAuth(authOptions);\n\nexport { handler as GET, handler as POST }; "],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;;;;;AAQA,MAAM,SAAS,IAAI,6HAAA,CAAA,eAAY;AAExB,MAAM,cAA2B;IACtC,WAAW;QACT,CAAA,GAAA,0JAAA,CAAA,UAAmB,AAAD,EAAE;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW,EAAE,GAAG;gBAC9B,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,IAAI;oBACF,4CAA4C;oBAC5C,iCAAiC;oBACjC;;;;;;;;;;;;;;;;;;;;;;;UAuBA,GAEA,yBAAyB;oBACzB,MAAM,OAAO,MAAM,OAAO,IAAI,CAAC,UAAU,CAAC;wBACxC,OAAO;4BAAE,OAAO,YAAY,KAAK;wBAAC;oBACpC;oBAEA,IAAI,MAAM;wBACR,MAAM,gBAAgB,MAAM,mIAAA,CAAA,UAAM,CAAC,OAAO,CAAC,YAAY,QAAQ,EAAE,KAAK,QAAQ;wBAE9E,IAAI,eAAe;4BACjB,uCAAuC;4BACvC,sDAAsD;4BAEtD,OAAO;gCACL,IAAI,KAAK,EAAE;gCACX,MAAM,KAAK,IAAI,IAAI;gCACnB,OAAO,KAAK,KAAK;gCACjB,MAAM,KAAK,IAAI;4BACjB;wBACF;oBACF;oBAEA,wDAAwD;oBACxD,MAAM,IAAI,MAAM;gBAElB,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,eAAe;oBAE7B,6BAA6B;oBAC7B,IAAI,iBAAiB,SAAS,MAAM,OAAO,CAAC,UAAU,CAAC,gBAAgB;wBACrE,MAAM;oBACR;oBACA,IAAI,iBAAiB,SAAS,MAAM,OAAO,CAAC,UAAU,CAAC,mBAAmB;wBACxE,MAAM;oBACR;oBAEA,2DAA2D;oBAC3D,OAAO;gBACT;YACF;QACF;KACD;IACD,SAAS;QAAE,UAAU;IAAM;IAC3B,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;YACjC;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,SAAS,QAAQ,IAAI,EAAE;gBACzB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG;gBAC3B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAChC;YACA,OAAO;QACT;QACA,MAAM,UAAS,EAAE,GAAG,EAAE,OAAO,EAAE;YAC7B,qDAAqD;YACrD,IAAI,IAAI,UAAU,CAAC,UAAU;gBAC3B,OAAO;YACT;YAEA,kCAAkC;YAClC,OAAO,UAAU;QACnB;IACF;IACA,OAAO,oDAAyB;AAClC;AAEA,MAAM,UAAU,CAAA,GAAA,uIAAA,CAAA,UAAQ,AAAD,EAAE","debugId":null}}]
}